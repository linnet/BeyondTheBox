<h3 id="beyond-the-box-distributed-computing-with-zeromq">Beyond the Box: Distributed Computing with ZeroMQ</h3>
<p>As fast and powerful as the PC has become, it's still not enough. Modern computing demands moving code up and out -- from threads to processes to machines to clusters. To do so intelligently requires solid tools and flexible techniques. In this example-driven talk, you'll learn how ZeroMQ, a library for distributed computing, provides the means to rise up to the challenges of modern computing. In particular, we will explore how a language-agnostic, pattern-based approach to message exchange may be used to deliver sophisticated and compelling distributed programming solutions.</p>
<p><em>Duration: ~75 minutes</em></p>
<p><em>Media: slides, code, print</em></p>
<p>=====</p>
<h4 id="outline">Outline</h4>
<ol>
<li>Introduction<ol>
<li>About the presenter</li>
<li>About ZeroMQ<ol>
<li>ZeroMQ is NOT middleware (i.e. it's not a message queue)</li>
<li>ZeroMQ can be used anytime logic needs to be split (threads, processes, machines, networks)</li>
<li>"Sockets" aren't really like actual (network) sockets... even if they seem familiar</li>
<li>Build in layers<ol>
<li>Wire protocol sits just above transport protocol (ZMTP)</li>
<li>Socket behavior sits just above wire protocol (libzmq)</li>
<li>App code sits just above socket behavior</li>
</ol>
</li>
<li>Communication and community<ol>
<li>FOSS</li>
<li>Designed and built by members of AMQP team</li>
<li>Well-defined protocols</li>
<li>Vibrant community (ZeroMQ GitHub org: 374 unique contributors - 12 Jun 2014)</li>
<li>Written in portable C/C++<ol>
<li>Native "ports" to Java, C#, Erlang</li>
</ol>
</li>
<li>45+ language bindings</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>Basic ZeroMQ Concepts<ol>
<li>Sockets passing (sending/receiving) messages<ol>
<li>Sends or Receives messages according to socket type</li>
<li>Message transmission may be blocking or non-blocking<ol>
<li>send/recv vs poll</li>
</ol>
</li>
<li>Connects or Binds to an endpoint according to topology</li>
<li>No shared state</li>
<li>Binary data (0 or more bytes) -- app provides meaning</li>
</ol>
</li>
<li>Transport Unification<ol>
<li>Change transport by changing address (string)</li>
<li>Popular transports include<ol>
<li>TCP</li>
<li>IPC -- doesn't work on Windows!</li>
<li>InProc (actor-based multi-threading)</li>
</ol>
</li>
</ol>
</li>
<li>One node (i.e. process, context, et cetera) can have many sockets<ol>
<li>Combining sockets helps seperate concerns</li>
<li>Combining sockets improves overall flexibility</li>
</ol>
</li>
</ol>
</li>
<li>ZeroMQ in detail<ol>
<li>Message-exchange patterns<ol>
<li>Determined by connecting certain Socket "roles"</li>
<li>Client/Server</li>
<li>Remote procedure call</li>
<li>Workflow (parallel, repeat, et cetera)</li>
<li>Data distribution</li>
</ol>
</li>
<li>Socket role<ol>
<li>Determines message-exchange behavior</li>
<li>send/recv pattern</li>
<li>routing strategy</li>
<li>compatible peers</li>
<li>"mute state" action</li>
</ol>
</li>
<li>Basic socket roles<ol>
<li>REQ   -- strictly synchronous send/recv, zmq handles tracking</li>
<li>REP   -- strictly synchronous recv/send, zmq handles tracking</li>
<li>PUSH  -- send messages downstream</li>
<li>PULL  -- recv upstream messages</li>
<li>PUB   -- send topical data</li>
<li>SUB   -- recv topical data, filtered by topic</li>
</ol>
</li>
</ol>
</li>
<li>More important concepts<ol>
<li>Context<ol>
<li>Heavywieght (thread-safe)<ol>
<li>Sockets are lightweight (NOT thread-safe)</li>
</ol>
</li>
<li>"Owns" Sockets</li>
<li>IS TRANSPORT for INPROC channels</li>
<li>Mulitple contexts in one process is like mulitple processes</li>
</ol>
</li>
<li>Multi-part messages<ol>
<li>Framing for structure (1 or more frames)</li>
<li>Must fit in memory</li>
<li>Guarenteed to be delivered whole or not at all</li>
</ol>
</li>
<li>Advanced socket roles<ol>
<li>DEALER -- interleaved send/recv, app must do tracking)</li>
<li>ROUTER -- interleaved recv/send, app must do tracking)</li>
<li>XPUB -- like PUB, but subscription info is shared</li>
<li>XSUB -- like XSUB, but subscription info is shared</li>
<li>PAIR -- exclusive channel between two INPROC nodes</li>
</ol>
</li>
</ol>
</li>
<li>Useful tooling<ul>
<li>Proxy<ol>
<li>In-the-box abstraction for shuttling messages between sockets</li>
<li>Also called: device, streamer, queue, forwarder</li>
<li>Not useful for custom routing logic</li>
</ol>
</li>
<li>Diagnostics<ol>
<li>Exposed at the Socket-level</li>
<li>Stream of events delivered via PAIR socket</li>
</ol>
</li>
</ul>
</li>
<li>Things we didn't cover<ol>
<li>Multicast protocols</li>
<li>Security framework</li>
<li>Non-ZMQ peers</li>
</ol>
</li>
<li>Conclusion<ol>
<li>Question &amp; Answer</li>
<li>Links about ZeroMQ</li>
<li>Links about the presentation</li>
<li>Links about the presenter</li>
</ol>
</li>
</ol>
<p>=====</p>
<h4 id="examples">Examples</h4>
<p></p><p><em>chatz</em></p><p></p>
<pre class="editor-colors">chatz.server (Rust, Console)
  # keeps track of connected (expiring) users
  # returns list of connected users
  ROUTER tcp://*:9001
    -&gt; [ UTF8(?usr:\w+)(\037(?msg:\w+)) ]
    &lt;- [ UTF8(?usr:\w+) ]+
  # broadcasts one user's message to entire group
  PUB tcp://*:9002
    &lt;&lt; [ UTF8(?usr:\w+)\037(?msg:\w+) ]

chatz.client (C#, WPF)
  # sends messages to server for broadcast
  REQ tcp://localhost:9001
  # gets messages broadcast by anyone in the group
  SUB tcp://localhost:9002
  ?&gt; [ UTF8("") ]
</pre>

<p></p><p><em>tickz</em></p><p></p>
<pre class="editor-colors">tickz.server (C, Server)
  # broadcast stock data
  PUB tcp://*:9003
  &lt;&lt; [ stock     : UTF8([A-Z][A-Z0-9]+) ]
     [ timestamp : f64                  ]
     [ price     : f64                  ]

tickz.client (VB, WinForms)
  # receive stock data from server
  SUB tcp://localhost:9003
  # user adds explicit stock symbols for which to receive data
  ?&gt; [ stock : UTF8([A-Z][A-Z0-9]+) ]*
</pre>

<p></p><p><em>valuz</em></p><p></p>
<pre class="editor-colors">                        worker |----[idling]----&gt; reduce
source &lt;----------[start of new batch]----------| reduce
source |---[domain]---&gt; worker
                        worker |---[codomain]---&gt; reduce
                        worker &lt;---[shutdown]---| reduce

valuz.source (Python, Console)
# sends batch data to worker(s) for processing
  PUSH tcp://*:9004
  &lt;- [ stock  : UTF8([A-Z][A-Z0-9]+)       ]
     [ action : UTF8(BUY = +1 | SELL = -1) ]
     [ price  : UTF8(f64)                  ]
# receives start signal from reducer
  SUB  tcp://localhost:9006
  ?&gt; [ UTF8('batch.start') ]

valuz.reduce (Python, Console)
# waits for worker(s) to signal readiness
# gets results of individual calculation from worker(s)
  PULL tcp://*:9005
  -&gt; []
  -&gt; [ value : UTF8(f64) ]
# sends control signal to source
# sends control signal to worker(s)
  PUB tcp://*:9006
  &lt;&lt; [ UTF8('batch.start') ]
  &lt;&lt; [ UTF8('batch.leave') ]

valuz.worker (Haskell, Console)
# gets input data from source
  PULL tcp://localhost:9004
  -&gt; [ stock  : UTF8([A-Z][A-Z0-9]+)       ]
     [ action : UTF8(BUY = +1 | SELL = -1) ]
     [ price  : UTF8(f64)                  ]
# sends calculated result to reducer
  PUSH tcp://localhost:9005
  &lt;- [ value : UTF8(f64) ]
# receives control signal from reducer
  SUB  tcp://localhost:9006
    ?&gt; [ UTF8('batch.leave') ]
</pre>
<p><em>dealz</em></p>
<pre class="editor-colors">dealz (F# + SignalR, Console w/ HTML + JS + CSS)
???
</pre>

<p>=====</p>
<h4 id="slide-deck">Slide Deck</h4>
<ol>
<li>Title + Presenter Info w/ logos<ol>
<li>Some background on presenter</li>
</ol>
</li>
<li>"No Message Queue" animated graphic<ol>
<li>ZeroMQ disclaimer</li>
<li>High-level summary</li>
<li>Notes about community</li>
</ol>
</li>
<li>?composition graphic?<ol>
<li>Basic concepts</li>
</ol>
</li>
<li>tickz topology<ol>
<li>run demo</li>
<li>review code</li>
</ol>
</li>
<li>?communication graphic?<ol>
<li>Detailed concepts</li>
</ol>
</li>
<li>chatz topology<ol>
<li>run demo</li>
<li>review code</li>
</ol>
</li>
<li>?coordination graphic?<ol>
<li>More important concepts</li>
</ol>
</li>
<li>valuz topology<ol>
<li>run demo</li>
<li>review code</li>
</ol>
</li>
<li>?complexity graphic?<ol>
<li>Putting it all together</li>
</ol>
</li>
<li>dealz topology<ol>
<li>run demo</li>
<li>review code</li>
</ol>
</li>
<li>?continuation graphic?<ol>
<li>Things not covered</li>
</ol>
</li>
<li>Title + Presenter Info</li>
</ol>
<p>=====</p>
<h4 id="document">Document</h4>
<ul>
<li>Brochure<ul>
<li>Cover (1 panel)</li>
<li>ZeroMQ "cheat sheet" (3 panels)</li>
<li>Important links about ZeroMQ (1 panel)</li>
<li>Brief info + links about present w/ photo (1 panel)</li>
</ul>
</li>
</ul>
<ul>
<li>Handouts<ul>
<li>Topology diagrams from demos</li>
<li>Code fragments from demos</li>
</ul>
</li>
</ul>
<p>=====</p>
<h4 id="concepts">Concepts</h4>
<ul>
<li><strong>Some names are misleading</strong><ul>
<li>ZeroMQ is NOT middleware (i.e. it's not a message queue)</li>
<li>ZeroMQ can be used anytime logic needs to be split (threads, processes, machines, networks)</li>
<li>"Sockets" aren't really like actual (network) sockets... even if they seem familiar</li>
</ul>
</li>
</ul>
<ul>
<li>Build in layers<ul>
<li>Wire protocol sits just above transport protocol (ZMTP)</li>
<li>Socket behavior sits just above wire protocol (libzmq)</li>
<li>App code sits just above socket behavior</li>
</ul>
</li>
<li>Transport Unification<ul>
<li>Unicast<ul>
<li>TCP</li>
<li>IPC (not available on Windows)</li>
<li>INPROC</li>
<li>TIPC (coming soon)</li>
</ul>
</li>
<li>Multicast<ul>
<li>PGM</li>
<li>EPGM</li>
</ul>
</li>
</ul>
</li>
<li>Message Passing<ul>
<li>No shared state</li>
<li>Binary data (0 or more bytes) -- app provides meaning</li>
<li>Framing for structure (1 or more frames)</li>
<li>Must fit in memory</li>
<li>Guarenteed to be delivered whole or not at all</li>
</ul>
</li>
<li>Message Exchange Pattern<ul>
<li>Determined by connecting certain Socket Types</li>
<li>Client-Server</li>
<li>Remote procedure call</li>
<li>Workflow (parallel, repeat, et cetera)</li>
<li>Data distribution</li>
</ul>
</li>
<li>Socket<ul>
<li>Lightweight (not thread-safe)</li>
<li>Sends or Receives messages according to socket type</li>
<li>Connects or Binds to and endpoint according to topology</li>
<li>Manages inbound and outbound message queues (not accessible in app)</li>
<li>Has monitoring system (for diagnostics)</li>
<li>Socket Type<ul>
<li>Determines message-exchange behavior<ul>
<li>send/recv pattern</li>
<li>routing strategy</li>
<li>compatible peers</li>
<li>"mute state" action</li>
</ul>
</li>
<li>REQ -- strictly synchronous send/recv, zmq handles tracking</li>
<li>REP -- strictly synchronous recv/send, zmq handles tracking</li>
<li>DEALER -- interleaved send/recv, app must do tracking)</li>
<li>ROUTER -- interleaved recv/send, app must do tracking)</li>
<li>PUSH -- send messages downstream</li>
<li>PULL -- recv upstream messages</li>
<li>PUB -- send topical data</li>
<li>SUB -- recv topical data, filtered by topic</li>
<li>XPUB -- like PUB, but subscription info is shared</li>
<li>XSUB -- like XSUB, but subscription info is shared</li>
<li>PAIR -- exclusive channel between two INPROC nodes</li>
<li>STREAM -- connect to non-ZeroMQ peer (via TCP)</li>
</ul>
</li>
</ul>
</li>
<li>Context<ul>
<li>Heavywieght (thread-safe)</li>
<li>"Owns" Sockets</li>
<li>IS TRANSPORT for INPROC channels</li>
<li>Mulitple contexts in one process is like mulitple processes</li>
</ul>
</li>
<li>Proxy<ul>
<li>In-the-box abstraction for shuttling messages between sockets</li>
<li>Also called: device, streamer, queue, forwarder</li>
<li>Not useful for custom routing logic</li>
</ul>
</li>
<li>Security<ul>
<li>Available from ZMTP v3</li>
<li>SASL conformant</li>
<li>peers, arbitrarily, become "clients" or "servers"</li>
<li>Extensible mechansim with 3 defaults<ul>
<li>NULL - no security at all (same as older versions of ZMTP)</li>
<li>PLAIN - username/password over plaintext, useful for internal networks or with transport-level encryption (eg: VPN)</li>
<li>CURVE - CurveCP handshake, adapted for TCP (eliptic curve crypto + perfect-forward secrecy)</li>
</ul>
</li>
<li>Pluggable authenticators (INPROC nodes) via well-defined protocol</li>
</ul>
</li>
</ul>
